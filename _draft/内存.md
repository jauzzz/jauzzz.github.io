---
title: 内存管理(操作系统)
tags: [os]
---



**内存管理，是由于 `multi-programming` 的发展而产生的.**



一开始，在计算机中只有一个程序，除了操作系统占用的内存，都是程序占用的.

![image-20190911153022090](https://tva1.sinaimg.cn/large/006y8mN6gy1g6vm27wgexj30ek09nwew.jpg)

后来，time-sharing 提供了单位时间里多个进程切换运行的能力，那么如何进行切换呢？

- 原进程仍然拥有全部内存，切换时保存状态，读取另一进程的状态（这种方式会带来非常沉重的切换开销）
- 一个进程是无法使用完所有内存的，将不同的进程存储在不同的内存地址空间里，互不影响

![image-20190911153431605](https://tva1.sinaimg.cn/large/006y8mN6gy1g6vm6hq0b6j30co0bf756.jpg)

于是，希望拥有一个内存管理机制：

1. 可以给多个程序分配内存（其中的每个程序都能正常运行）
2. 访问隔离（多进程会带来安全问题，这是由于进程的内存是动态增长的，如果不进行隔离，a进程就能访问到b进程的内存）

<br>

对于上面的描述，我们建立一个抽象: `address space`

- address space 是一个进程所拥有的内存
- 对于进程，它的地址空间是专属的，从零开始使用
- 对于操作系统，需要进行 `地址空间 --> 物理内存` 的映射转换

基于这个抽象，我们设计了一个映射机制：`Memory segmentation`

- 对于一个进程所占用的内存部分，分成不同段(code、heap、stack)
- 一个段构成一个独立的地址空间，其长度可以不同，并且可以动态增长
- 分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于**共享和保护**

<br>

但是分段有一个严重的问题，`内存碎片`

- 内部碎片，进程无法使用完分配的内存（通常无法避免）
- 外部碎片，由于频繁的分配和回收，产生了大量的连续且小的连续内存区域，就会导致可用内存越来越少
- 外部碎片产生的真正原因是：**分配在物理上是连续的，在逻辑上是整块的**

因此，引入了新的内存分配单元：`page`

- 分页是将地址空间划分成固定大小的页
- 每个段可以由多个页组成，且不必连续就减少了外部碎片
- page很小，这样就减少了内部碎片

同时，引入了页面的映射方式：`page table`

- a per-process data structure
- record where each virtual page of the address space is placed in physical memory

<br>

由于 `page` 足够小，所以数目会很多，page table 的项也会对应很多，而且每个进程都要维护一份自己的 page table，会有非常大的内存占用.

造成 page table 占用大的原因主要有两个：

1. page 小（因此可以通过支持较大page的方式来减少占用）
2. 未使用的page也需要记录（完整的page table里，未占用的page占了大部分，而这些都得记录）



<br>

内存的需求是永远不够的，为了使用更多的内存，设计了`内存置换`：

- 将当前不用的内存块里的数据，存放到其他存储设备，以空出当前内存块
- 如果内存分配单元是页面，就称为页面置换

页面置换与缓存更新类似，需要淘汰一部分已存在的缓存，然后存放新的缓存数据.

页面置换算法的主要目标是使页面置换频率最低(也可以说缺页率最低).

- `OPT`: **最佳替换算法**
  将之后最不需要用到的页面替换出去
  可以获得最低的缺页率，但这是个理论算法，因为不可能知道一个页面未来的访问情况.

- `LRU`: **最久未使用**
  虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况.
  为了实现 LRU，需要在内存中维护一个所有页面的链表.

  当一个页面被访问时，将这个页面移到链表表头，这样就能保证链表表尾的页面是最近最久未访问的.
  因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高.

- `NRU`: **最近未使用**

  每个页面都有两个状态位: R 与 M
  当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零.

  当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出.
  优先换出已经被修改的脏页面(R=0，M=1)，而不是被频繁使用的干净页面(R=1，M=0).

- `FIFO`: **First In First Out**
  最先进去的最先被替换
  该算法容易将频繁访问的页面替换出去从而使缺页率升高.

- `第二次机会`: **FIFO & NRU**

  按照FIFO的顺序，但是会检查页面的 R 位.
  如果 R=0，说明页面没有被访问，可以被置换掉;
  如果 R=1，就将R位置零，并放在链表尾端，然后继续搜索下一个.

- `CLOCK`: **时钟**

  第二次机会算法需要在链表中移动页面，降低了效率.
  时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面.

  

## Reference

- [操作系统页面置换算法简介](https://aidandai.github.io/posts/the-page-replacement-algorithm.html)